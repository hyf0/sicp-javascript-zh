<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《计算机程序的构造与解释》JavaScript版</title>
    <meta name="description" content="暂无">
    
    
    <link rel="preload" href="/sicp-javascript-zh/assets/css/0.styles.929c33a3.css" as="style"><link rel="preload" href="/sicp-javascript-zh/assets/js/app.9215d83a.js" as="script"><link rel="preload" href="/sicp-javascript-zh/assets/js/2.6b5425dd.js" as="script"><link rel="preload" href="/sicp-javascript-zh/assets/js/12.1fd29f9b.js" as="script"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/10.93a7fb74.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/11.860ce0d5.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/13.23219ac8.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/3.bc8de7d9.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/4.f60551b5.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/5.7a67636c.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/6.42169431.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/7.6ad2635f.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/8.46310511.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/9.45d208c9.js">
    <link rel="stylesheet" href="/sicp-javascript-zh/assets/css/0.styles.929c33a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sicp-javascript-zh/" class="home-link router-link-active"><!----> <span class="site-name">《计算机程序的构造与解释》JavaScript版</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/iheyunfei/sicp-javascript-zh" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/iheyunfei/sicp-javascript-zh" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/sicp-javascript-zh/" class="sidebar-link">目录</a></li><li><a href="/sicp-javascript-zh/foreword.html" class="sidebar-link">荐言</a></li><li><a href="/sicp-javascript-zh/prefaces.html" class="sidebar-link">前言</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/sicp-javascript-zh/chapter1.html" class="sidebar-link">1 使用函数构造抽象</a></li><li><a href="/sicp-javascript-zh/chapter1.1.html" class="sidebar-link">1.1 编程的基本元素</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><ul><li><p>Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister, Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992. The Supercomputer Toolkit: A general framework for special-purpose computing. International Journal of High-Speed Electronics 3(3):337-361.</p></li> <li><p>Allen, John. 1978. Anatomy of Lisp. New York: McGraw-Hill.</p></li> <li><p>ANSI X3.226-1994. American National Standard for Information Systems—Programming Language—Common Lisp.</p></li> <li><p>Appel, Andrew W. 1987. Garbage collection can be faster than stack allocation. Information Processing Letters 25(4):275-279.</p></li> <li><p>Backus, John. 1978. Can programming be liberated from the von Neumann style? Communications of the ACM 21(8):613-641.</p></li> <li><p>Baker, Henry G., Jr. 1978. List processing in real time on a serial computer. Communications of the ACM 21(4):280-293.</p></li> <li><p>Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise. 1982. The Scheme-81 architecture—System and chip. In Proceedings of the MIT Conference on Advanced Research in VLSI, edited by Paul Penfield, Jr. Dedham, MA: Artech House.</p></li> <li><p>Borning, Alan. 1977. ThingLab—An object-oriented system for building simulations using constraints. In Proceedings of the 5th International Joint Conference on Artificial Intelligence.</p></li> <li><p>Borodin, Alan, and Ian Munro. 1975. The Computational Complexity of Algebraic and Numeric Problems. New York: American Elsevier.</p></li> <li><p>Chaitin, Gregory J. 1975. Randomness and mathematical proof. Scientific American 232(5):47-52.</p></li> <li><p>Church, Alonzo. 1941. The Calculi of Lambda-Conversion. Princeton, N.J.: Princeton University Press.</p></li> <li><p>Clark, Keith L. 1978. Negation as failure. In Logic and Data Bases. New York: Plenum Press, pp. 293-322.</p></li> <li><p>Clinger, William. 1982. Nondeterministic call by need is neither lazy nor by name. In Proceedings of the ACM Symposium on Lisp and Functional Programming, pp. 226-234.</p></li> <li><p>Clinger, William, and Jonathan Rees. 1991. Macros that work. In Proceedings of the 1991 ACM Conference on Principles of Programming Languages, pp. 155-162.</p></li> <li><p>Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel. 1973. Un système de communication homme-machine en français. Technical report, Groupe Intelligence Artificielle, Université d'Aix Marseille, Luminy.</p></li> <li><p>Cormen, Thomas, Charles Leiserson, and Ronald Rivest. 1990. Introduction to Algorithms. Cambridge, MA: MIT Press.</p></li> <li><p>Darlington, John, Peter Henderson, and David Turner. 1982. Functional Programming and Its Applications. New York: Cambridge University Press.</p></li> <li><p>Dijkstra, Edsger W. 1968a. The structure of the THE multiprogramming system. Communications of the ACM 11(5):341-346.</p></li> <li><p>Dijkstra, Edsger W. 1968b. Cooperating sequential processes. In Programming Languages, edited by F. Genuys. New York: Academic Press, pp. 43-112.</p></li> <li><p>Dinesman, Howard P. 1968. Superior Mathematical Puzzles. New York: Simon and Schuster.</p></li> <li><p>deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman. 1977. AMORD: Explicit control of reasoning. In Proceedings of the ACM Symposium on Artificial Intelligence and Programming Languages, pp. 116-125.</p></li> <li><p>Doyle, Jon. 1979. A truth maintenance system. Artificial Intelligence 12:231-272.</p></li> <li><p>Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National Fifth Generation Project: Introduction, survey, and evaluation. In Future Generation Computer Systems, vol. 9, pp. 105-117.</p></li> <li><p>Feeley, Marc. 1986. Deux approches à l'implantation du language Scheme. Masters thesis, Université de Montréal.</p></li> <li><p>Feeley, Marc and Guy Lapalme. 1987. Using closures for code generation. Journal of Computer Languages 12(1):47-66.</p></li> <li><p>Feller, William. 1957. An Introduction to Probability Theory and Its Applications, volume 1. New York: John Wiley &amp; Sons.</p></li> <li><p>Fenichel, R., and J. Yochelson. 1969. A Lisp garbage collector for virtual memory computer systems. Communications of the ACM 12(11):611-612.</p></li> <li><p>Floyd, Robert. 1967. Nondeterministic algorithms. JACM, 14(4):636-644.</p></li> <li><p>Forbus, Kenneth D., and Johan deKleer. 1993. Building Problem Solvers. Cambridge, MA: MIT Press.</p></li> <li><p>Friedman, Daniel P., and David S. Wise. 1976. CONS should not evaluate its arguments. In Automata, Languages, and Programming: Third International Colloquium, edited by S. Michaelson and R. Milner, pp. 257-284.</p></li> <li><p>Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992. Essentials of Programming Languages. Cambridge, MA: MIT Press/McGraw-Hill.</p></li> <li><p>Gabriel, Richard P. 1988. The Why of Y. Lisp Pointers 2(2):15-25.</p></li> <li><p>Goldberg, Adele, and David Robson. 1983. Smalltalk-80: The Language and Its Implementation. Reading, MA: Addison-Wesley.</p></li> <li><p>Gordon, Michael, Robin Milner, and Christopher Wadsworth. 1979. Edinburgh LCF. Lecture Notes in Computer Science, volume 78. New York: Springer-Verlag.</p></li> <li><p>Gray, Jim, and Andreas Reuter. 1993. Transaction Processing: Concepts and Models. San Mateo, CA: Morgan-Kaufman.</p></li> <li><p>Green, Cordell. 1969. Application of theorem proving to problem solving. In Proceedings of the International Joint Conference on Artificial Intelligence, pp. 219-240.</p></li> <li><p>Green, Cordell, and Bertram Raphael. 1968. The use of theorem-proving techniques in question-answering systems. In Proceedings of the ACM National Conference, pp. 169-181.</p></li> <li><p>Griss, Martin L. 1981. Portable Standard Lisp, a brief overview. Utah Symbolic Computation Group Operating Note 58, University of Utah.</p></li> <li><p>Guttag, John V. 1977. Abstract data types and the development of data structures. Communications of the ACM 20(6):397-404.</p></li> <li><p>Hamming, Richard W. 1980. Coding and Information Theory. Englewood Cliffs, N.J.: Prentice-Hall.</p></li> <li><p>Hanson, Christopher P. 1990. Efficient stack allocation for tail-recursive languages. In Proceedings of ACM Conference on Lisp and Functional Programming, pp. 106-118.</p></li> <li><p>Hanson, Christopher P. 1991. A syntactic closures macro facility. Lisp Pointers, 4(3).</p></li> <li><p>Hardy, Godfrey H. 1921. Srinivasa Ramanujan. Proceedings of the London Mathematical Society XIX(2).</p></li> <li><p>Hardy, Godfrey H., and E. M. Wright. 1960. An Introduction to the Theory of Numbers. 4th edition. New York: Oxford University Press.</p></li> <li><p>Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. IBM Systems Journal 7(2):74-84.</p></li> <li><p>Hearn, Anthony C. 1969. Standard Lisp. Technical report AIM-90, Artificial Intelligence Project, Stanford University.</p></li> <li><p>Henderson, Peter. 1980. Functional Programming: Application and Implementation. Englewood Cliffs, N.J.: Prentice-Hall.</p></li> <li><p>Henderson. Peter. 1982. Functional Geometry. In Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming, pp. 179-187.</p></li> <li><p>Hewitt, Carl E. 1969. PLANNER: A language for proving theorems in robots. In Proceedings of the International Joint Conference on Artificial Intelligence, pp. 295-301.</p></li> <li><p>Hewitt, Carl E. 1977. Viewing control structures as patterns of passing messages. Journal of Artificial Intelligence 8(3):323-364.</p></li> <li><p>Hoare, C. A. R. 1972. Proof of correctness of data representations. Acta Informatica 1(1).</p></li> <li><p>Hodges, Andrew. 1983. Alan Turing: The Enigma. New York: Simon and Schuster.</p></li> <li><p>Hofstadter, Douglas R. 1979. Gödel, Escher, Bach: An Eternal Golden Braid. New York: Basic Books.</p></li> <li><p>Hughes, R. J. M. 1990. Why functional programming matters. In Research Topics in Functional Programming, edited by David Turner. Reading, MA: Addison-Wesley, pp. 17-42.</p></li> <li><p>IEEE Std 1178-1990. 1990. IEEE Standard for the Scheme Programming Language.</p></li> <li><p>Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by M. Lind, Herbert Kanner, and Robert Floyd. 1960. THUNKS: A way of compiling procedure statements, with some comments on procedure declarations. Unpublished manuscript. (Also, private communication from Wallace Feurzeig.)</p></li> <li><p>Kaldewaij, Anne. 1990. Programming: The Derivation of Algorithms. New York: Prentice-Hall.</p></li> <li><p>Kohlbecker, Eugene Edmund, Jr. 1986. Syntactic extensions in the programming language Lisp. Ph.D. thesis, Indiana University.</p></li> <li><p>Konopasek, Milos, and Sundaresan Jayaraman. 1984. The TK!Solver Book: A Guide to Problem-Solving in Science, Engineering, Business, and Education. Berkeley, CA: Osborne/McGraw-Hill.</p></li> <li><p>Knuth, Donald E. 1973. Fundamental Algorithms. Volume 1 of The Art of Computer Programming. 2nd edition. Reading, MA: Addison-Wesley.</p></li> <li><p>Knuth, Donald E. 1981. Seminumerical Algorithms. Volume 2 of The Art of Computer Programming. 2nd edition. Reading, MA: Addison-Wesley.</p></li> <li><p>Kowalski, Robert. 1973. Predicate logic as a programming language. Technical report 70, Department of Computational Logic, School of Artificial Intelligence, University of Edinburgh.</p></li> <li><p>Kowalski, Robert. 1979. Logic for Problem Solving. New York: North-Holland.</p></li> <li><p>Lamport, Leslie. 1978. Time, clocks, and the ordering of events in a distributed system. Communications of the ACM 21(7):558-565.</p></li> <li><p>Lampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K. Popek. 1981. Report on the programming language Euclid. Technical report, Computer Systems Research Group, University of Toronto.</p></li> <li><p>Landin, Peter. 1965. A correspondence between Algol 60 and Church's lambda notation: Part I. Communications of the ACM 8(2):89-101.</p></li> <li><p>Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector based on the lifetimes of objects. Communications of the ACM 26(6):419-429.</p></li> <li><p>Liskov, Barbara H., and Stephen N. Zilles. 1975. Specification techniques for data abstractions. IEEE Transactions on Software Engineering 1(1):7-19.</p></li> <li><p>McAllester, David Allen. 1978. A three-valued truth-maintenance system. Memo 473, MIT Artificial Intelligence Laboratory.</p></li> <li><p>McAllester, David Allen. 1980. An outlook on truth maintenance. Memo 551, MIT Artificial Intelligence Laboratory.</p></li> <li><p>McCarthy, John. 1960. Recursive functions of symbolic expressions and their computation by machine. Communications of the ACM 3(4):184-195.</p></li> <li><p>McCarthy, John. 1967. A basis for a mathematical theory of computation. In Computer Programing and Formal Systems, edited by P. Braffort and D. Hirschberg. North-Holland.</p></li> <li><p>McCarthy, John. 1978. The history of Lisp. In Proceedings of the ACM SIGPLAN Conference on the History of Programming Languages.</p></li> <li><p>McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I. Levin. 1965. Lisp 1.5 Programmer's Manual. 2nd edition. Cambridge, MA: MIT Press.</p></li> <li><p>McDermott, Drew, and Gerald Jay Sussman. 1972. Conniver reference manual. Memo 259, MIT Artificial Intelligence Laboratory.</p></li> <li><p>Miller, Gary L. 1976. Riemann's Hypothesis and tests for primality. Journal of Computer and System Sciences 13(3):300-317.</p></li> <li><p>Miller, James S., and Guillermo J. Rozas. 1994. Garbage collection is fast, but a stack is faster. Memo 1462, MIT Artificial Intelligence Laboratory.</p></li> <li><p>Moon, David. 1978. MacLisp reference manual, Version 0. Technical report, MIT Laboratory for Computer Science.</p></li> <li><p>Moon, David, and Daniel Weinreb. 1981. Lisp machine manual. Technical report, MIT Artificial Intelligence Laboratory.</p></li> <li><p>Morris, J. H., Eric Schmidt, and Philip Wadler. 1980. Experience with an applicative string processing language. In Proceedings of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of Programming Languages.</p></li> <li><p>Phillips, Hubert. 1934. The Sphinx Problem Book. London: Faber and Faber.</p></li> <li><p>Pitman, Kent. 1983. The revised MacLisp Manual (Saturday evening edition). Technical report 295, MIT Laboratory for Computer Science.</p></li> <li><p>Rabin, Michael O. 1980. Probabilistic algorithm for testing primality. Journal of Number Theory 12:128-138.</p></li> <li><p>Raymond, Eric. 1993. The New Hacker's Dictionary. 2nd edition. Cambridge, MA: MIT Press.</p></li> <li><p>Raynal, Michel. 1986. Algorithms for Mutual Exclusion. Cambridge, MA: MIT Press.</p></li> <li><p>Rees, Jonathan A., and Norman I. Adams IV. 1982. T: A dialect of Lisp or, lambda: The ultimate software tool. In Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming, pp. 114-122.</p></li> <li><p>Rees, Jonathan, and William Clinger (eds). 1991. The revised44 report on the algorithmic language Scheme. Lisp Pointers, 4(3).</p></li> <li><p>Rivest, Ronald, Adi Shamir, and Leonard Adleman. 1977. A method for obtaining digital signatures and public-key cryptosystems. Technical memo LCS/TM82, MIT Laboratory for Computer Science.</p></li> <li><p>Robinson, J. A. 1965. A machine-oriented logic based on the resolution principle. Journal of the ACM 12(1):23.</p></li> <li><p>Robinson, J. A. 1983. Logic programming—Past, present, and future. New Generation Computing 1:107-124.</p></li> <li><p>Sagade, Y. 2015. SICP exercise 1.14</p></li> <li><p>Spafford, Eugene H. 1989. The Internet Worm: Crisis and aftermath. Communications of the ACM 32(6):678-688.</p></li> <li><p>Steele, Guy Lewis, Jr. 1977. Debunking the expensive procedure call myth. In Proceedings of the National Conference of the ACM, pp. 153-62.</p></li> <li><p>Steele, Guy Lewis, Jr. 1982. An overview of Common Lisp. In Proceedings of the ACM Symposium on Lisp and Functional Programming, pp. 98-107.</p></li> <li><p>Steele, Guy Lewis, Jr. 1990. Common Lisp: The Language. 2nd edition. Digital Press.</p></li> <li><p>Steele, Guy Lewis, Jr., and Gerald Jay Sussman. 1975. Scheme: An interpreter for the extended lambda calculus. Memo 349, MIT Artificial Intelligence Laboratory.</p></li> <li><p>Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R. Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow. 1983. The Hacker's Dictionary. New York: Harper &amp; Row.</p></li> <li><p>Stoy, Joseph E. 1977. Denotational Semantics. Cambridge, MA: MIT Press.</p></li> <li><p>Sussman, Gerald Jay, and Richard M. Stallman. 1975. Heuristic techniques in computer-aided circuit analysis. IEEE Transactions on Circuits and Systems CAS-22(11):857-865.</p></li> <li><p>Sussman, Gerald Jay, and Guy Lewis Steele Jr. 1980. Constraints—A language for expressing almost-hierachical descriptions. AI Journal 14:1-39.</p></li> <li><p>Sussman, Gerald Jay, and Jack Wisdom. 1992. Chaotic evolution of the solar system. Science 257:256-262.</p></li> <li><p>Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak. 1971. Microplanner reference manual. Memo 203A, MIT Artificial Intelligence Laboratory.</p></li> <li><p>Sutherland, Ivan E. 1963. SKETCHPAD: A man-machine graphical communication system. Technical report 296, MIT Lincoln Laboratory.</p></li> <li><p>Teitelman, Warren. 1974. Interlisp reference manual. Technical report, Xerox Palo Alto Research Center.</p></li> <li><p>Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978. Data type specification: Parameterization and the power of specification techniques. In Conference Record of the Tenth Annual ACM Symposium on Theory of Computing, pp. 119-132. Turner, David. 1981. The future of applicative languages. In Proceedings of the 3rd European Conference on Informatics, Lecture Notes in Computer Science, volume 123. New York: Springer-Verlag, pp. 334-348.</p></li> <li><p>Wand, Mitchell. 1980. Continuation-based program transformation strategies. Journal of the ACM 27(1):164-180.</p></li> <li><p>Waters, Richard C. 1979. A method for analyzing loop programs. IEEE Transactions on Software Engineering 5(3):237-247.</p></li> <li><p>Winograd, Terry. 1971. Procedures as a representation for data in a computer program for understanding natural language. Technical report AI TR-17, MIT Artificial Intelligence Laboratory.</p></li> <li><p>Winston, Patrick. 1992. Artificial Intelligence. 3rd edition. Reading, MA: Addison-Wesley.</p></li> <li><p>Zabih, Ramin, David McAllester, and David Chapman. 1987. Non-deterministic Lisp with dependency-directed backtracking. AAAI-87, pp. 59-64.</p></li> <li><p>Zippel, Richard. 1979. Probabilistic algorithms for sparse polynomials. Ph.D. dissertation, Department of Electrical Engineering and Computer Science, MIT.</p></li> <li><p>Zippel, Richard. 1993. Effective Polynomial Computation. Boston, MA: Kluwer Academic Publishers.</p></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">8/22/2019, 12:34:49 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/sicp-javascript-zh/assets/js/app.9215d83a.js" defer></script><script src="/sicp-javascript-zh/assets/js/2.6b5425dd.js" defer></script><script src="/sicp-javascript-zh/assets/js/12.1fd29f9b.js" defer></script>
  </body>
</html>
