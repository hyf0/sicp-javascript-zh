<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | 《计算机程序的构造与解释》JavaScript版</title>
    <meta name="description" content="暂无">
    
    
    <link rel="preload" href="/sicp-javascript-zh/assets/css/0.styles.929c33a3.css" as="style"><link rel="preload" href="/sicp-javascript-zh/assets/js/app.9215d83a.js" as="script"><link rel="preload" href="/sicp-javascript-zh/assets/js/2.6b5425dd.js" as="script"><link rel="preload" href="/sicp-javascript-zh/assets/js/11.860ce0d5.js" as="script"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/10.93a7fb74.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/12.1fd29f9b.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/13.23219ac8.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/3.bc8de7d9.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/4.f60551b5.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/5.7a67636c.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/6.42169431.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/7.6ad2635f.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/8.46310511.js"><link rel="prefetch" href="/sicp-javascript-zh/assets/js/9.45d208c9.js">
    <link rel="stylesheet" href="/sicp-javascript-zh/assets/css/0.styles.929c33a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sicp-javascript-zh/" class="home-link router-link-active"><!----> <span class="site-name">《计算机程序的构造与解释》JavaScript版</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/iheyunfei/sicp-javascript-zh" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/iheyunfei/sicp-javascript-zh" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/sicp-javascript-zh/" class="sidebar-link">目录</a></li><li><a href="/sicp-javascript-zh/foreword.html" class="sidebar-link">荐言</a></li><li><a href="/sicp-javascript-zh/prefaces.html" class="active sidebar-link">前言</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sicp-javascript-zh/prefaces.html#preface-of-javascript-adaptation" class="sidebar-link">Preface of JavaScript Adaptation</a></li><li class="sidebar-sub-header"><a href="/sicp-javascript-zh/prefaces.html#preface-to-the-second-edition" class="sidebar-link">Preface to the Second Edition</a></li><li class="sidebar-sub-header"><a href="/sicp-javascript-zh/prefaces.html#preface-to-the-first-edition" class="sidebar-link">Preface to the First Edition</a></li></ul></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/sicp-javascript-zh/chapter1.html" class="sidebar-link">1 使用函数构造抽象</a></li><li><a href="/sicp-javascript-zh/chapter1.1.html" class="sidebar-link">1.1 编程的基本元素</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h1> <h2 id="preface-of-javascript-adaptation"><a href="#preface-of-javascript-adaptation" aria-hidden="true" class="header-anchor">#</a> Preface of JavaScript Adaptation</h2> <p>You are reading the textbook Structure and Interpretation of Computer Programs by Harold Abelson and Gerald Sussman—with a twist. The textbook emphasizes the importance of abstraction for managing complexity, and introduces the reader to a host of concepts that lie at the heart of the field of computer science. Most of these ideas are independent of the programming language used to express them to employ actual computers for solving computational problems. They are programming-language independent. The twist then consists of replacing the programming language that is used in the examples. While the authors had used the programming language Scheme, this adaptation uses the language JavaScript.</p> <p>More precisely, this adaptation uses five tiny, carefully designed, sublanguages of JavaScript. The languages are called Source §1, Source §2, Source §3, Source §4 and Source §5, corresponding to the respective chapters 1, 2, 3, 4 and 5 of the textbook. The Source §1 language contains only constructs that are needed in the programs contained in chapter 1: constructs required to build abstractions with functions. Source §2 is a superset of Source §1; adding features required to build abstractions with data, on top of the features of Source §1. Similarly, Source §3, 4 and 5 extend the previous language features required to address the subject of the respective textbook chapter. All these languages are sub-languages of JavaScript; any Source program is also a JavaScript program. The reverse is not true. The JavaScript language has many features that are not covered in this textbook. Indeed, the Source languages are so small that they can be quite adquately described in a few pages of text. The online folder source contains the specifications of the Source languages, as reference for the reader.</p> <p>This textbook is interactive. Most programs are links. Clicking on them takes the reader to a web-based programming environment called the Source Academy. In the Source Academy, the reader can run the programs, modify them and experiment with them, without the need to install any software, and without any requirements on the computer that they use, as long as it comes with an internet browser.</p> <p>The language Scheme has been designed as a sublanguage of Lisp with its use in education as a central design objective. The language JavaScript, on the other hand, was not designed with the needs of learners in mind. This makes it difficult to use JavaScript in a course, even if one imposes constraints on the language features to be covered. The reason is that students with prior knowledge of the language are bound to make use of other features in their programs. Fellow students will legitimately ask the instructors about those features, and any answer will either frustate the student or lead to a tangent that is most likely not conducive to the learning objectives. This problem is especially severe for JavaScript, which is not known for its systematic design. Our solution to this challenge is radical: The Source Academy enforces the use of the respective Source language when the student clicks on a program of a particular chapter. Programs that use constructs beyond that language are rejected by the Source Academy. This allows instructors of a SICP-based course to adopt JavaScript—one of the most widely used programming languages today—without getting bogged down in JavaScript's plethora of idiosyncratic features.</p> <p>The original textbook was introduced to the National University of Singapore by Jacob Katzenelson in 1997, as a more advanced alternative to the regular Programming Methodology course offered to computer science students. The course, known as CS1101S since 1998, switched to JavaScript in 2012, and became the required freshmen programming methodology course for Computer Science undergraduate majors in 2018.</p> <blockquote><p>—— Martin Henz</p></blockquote> <h2 id="preface-to-the-second-edition"><a href="#preface-to-the-second-edition" aria-hidden="true" class="header-anchor">#</a> Preface to the Second Edition</h2> <blockquote><p>Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as a soap bubble?
—— Alan J. Perlis</p></blockquote> <p>The material in this book has been the basis of MIT's entry-level computer science subject since 1980. We had been teaching this material for four years when the first edition was published, and twelve more years have elapsed until the appearance of this second edition. We are pleased that our work has been widely adopted and incorporated into other texts. We have seen our students take the ideas and programs in this book and build them in as the core of new computer systems and languages. In literal realization of an ancient Talmudic pun, our students have become our builders. We are lucky to have such capable students and such accomplished builders.</p> <p>In preparing this edition, we have incorporated hundreds of clarifications suggested by our own teaching experience and the comments of colleagues at MIT and elsewhere. We have redesigned most of the major programming systems in the book, including the generic-arithmetic system, the interpreters, the register-machine simulator, and the compiler; and we have rewritten all the program examples to ensure that any Scheme implementation conforming to the IEEE Scheme standard (IEEE 1990) will be able to run the code.</p> <p>This edition emphasizes several new themes. The most important of these is the central role played by different approaches to dealing with time in computational models: objects with state, concurrent programming, functional programming, lazy evaluation, and nondeterministic programming. We have included new sections on concurrency and nondeterminism, and we have tried to integrate this theme throughout the book.</p> <p>The first edition of the book closely followed the syllabus of our MIT one-semester subject. With all the new material in the second edition, it will not be possible to cover everything in a single semester, so the instructor will have to pick and choose. In our own teaching, we sometimes skip the section on logic programming (section ), we have students use the register-machine simulator but we do not cover its implementation (section ), and we give only a cursory overview of the compiler (section ). Even so, this is still an intense course. Some instructors may wish to cover only the first three or four chapters, leaving the other material for subsequent courses.</p> <p>The World-Wide-Web site of MIT Press provides support for users of this book. This includes programs from the book, sample programming assignments, supplementary materials, and downloadable implementations of the Scheme dialect of Lisp.</p> <blockquote><p>—— Harold Abelson and Gerald Jay Sussman</p></blockquote> <h2 id="preface-to-the-first-edition"><a href="#preface-to-the-first-edition" aria-hidden="true" class="header-anchor">#</a> Preface to the First Edition</h2> <blockquote><p>A computer is like a violin. You can imagine a novice trying first a phonograph and then a violin. The latter, he says, sounds terrible. That is the argument we have heard from our humanists and most of our computer scientists. Computer programs are good, they say, for particular purposes, but they aren't flexible. Neither is a violin, or a typewriter, until you learn how to use it.
—— Marvin Minsky, &quot;Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas&quot;</p></blockquote> <p>&quot;The Structure and Interpretation of Computer Programs&quot; is the entry-level subject in computer science at the Massachusetts Institute of Technology. It is required of all students at MIT who major in electrical engineering or in computer science, as one-fourth of the &quot;common core curriculum&quot;, which also includes two subjects on circuits and linear systems and a subject on the design of digital systems. We have been involved in the development of this subject since 1978, and we have taught this material in its present form since the fall of 1980 to between 600 and 700 students each year. Most of these students have had little or no prior formal training in computation, although many have played with computers a bit and a few have had extensive programming or hardware-design experience.</p> <p>Our design of this introductory computer-science subject reflects two major concerns. First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute. Second, we believe that the essential material to be addressed by a subject at this level is not the syntax of particular programming-language constructs, nor clever algorithms for computing particular functions efficiently, nor even the mathematical analysis of algorithms and the foundations of computing, but rather the techniques used to control the intellectual complexity of large software systems.</p> <p>Our goal is that students who complete this subject should have a good feel for the elements of style and the aesthetics of programming. They should have command of the major techniques for controlling complexity in a large system. They should be capable of reading a 50-page-long program, if it is written in an exemplary style. They should know what not to read, and what they need not understand at any moment. They should feel secure about modifying a program, retaining the spirit and style of the original author.</p> <p>These skills are by no means unique to computer programming. The techniques we teach and draw upon are common to all of engineering design. We control complexity by building abstractions that hide details when appropriate. We control complexity by establishing conventional interfaces that enable us to construct systems by combining standard, well-understood pieces in a mix and match way. We control complexity by establishing new languages for describing a design, each of which emphasizes particular aspects of the design and deemphasizes others.</p> <p>Underlying our approach to this subject is our conviction that computer science is not a science and that its significance has little to do with computers. The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called procedural epistemology—the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects. Mathematics provides a framework for dealing precisely with notions of what is. Computation provides a framework for dealing precisely with notions of how to.</p> <p>In teaching our material we use a dialect of the programming language Lisp. We never formally teach the language, because we don't have to. We just use it, and students pick it up in a few days. This is one great advantage of Lisp-like languages: They have very few ways of forming compound expressions, and almost no syntactic structure. All of the formal properties can be covered in an hour, like the rules of chess. After a short time we forget about syntactic details of the language (because there are none) and get on with the real issues—figuring out what we want to compute, how we will decompose problems into manageable parts, and how we will work on the parts. Another advantage of Lisp is that it supports (but does not enforce) more of the large-scale strategies for modular decomposition of programs than any other language we know. We can make procedural and data abstractions, we can use higher-order functions to capture common patterns of usage, we can model local state using assignment and data mutation, we can link parts of a program with streams and delayed evaluation, and we can easily implement embedded languages. All of this is embedded in an interactive environment with excellent support for incremental program design, construction, testing, and debugging. We thank all the generations of Lisp wizards, starting with John McCarthy, who have fashioned a fine tool of unprecedented power and elegance.</p> <p>Scheme, the dialect of Lisp that we use, is an attempt to bring together the power and elegance of Lisp and Algol. From Lisp we take the metalinguistic power that derives from the simple syntax, the uniform representation of programs as data objects, and the garbage-collected heap-allocated data. From Algol we take lexical scoping and block structure, which are gifts from the pioneers of programming-language design who were on the Algol committee. We wish to cite John Reynolds and Peter Landin for their insights into the relationship of Church's lambda calculus to the structure of programming languages. We also recognize our debt to the mathematicians who scouted out this territory decades before computers appeared on the scene. These pioneers include Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry.</p> <blockquote><p>—— Harold Abelson and Gerald Jay Sussman</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">8/22/2019, 12:34:49 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/sicp-javascript-zh/foreword.html" class="prev">
          荐言
        </a></span> <span class="next"><a href="/sicp-javascript-zh/chapter1.html">
          1 使用函数构造抽象
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sicp-javascript-zh/assets/js/app.9215d83a.js" defer></script><script src="/sicp-javascript-zh/assets/js/2.6b5425dd.js" defer></script><script src="/sicp-javascript-zh/assets/js/11.860ce0d5.js" defer></script>
  </body>
</html>
